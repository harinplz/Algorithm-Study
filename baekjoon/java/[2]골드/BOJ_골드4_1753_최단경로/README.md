# BOJ 골드4 1753 최단 경로

- 순환 탐색 방법과 우선 순위 큐 방식을 둘 다 사용하여 문제를 풀이했다.
- 우선 순위 큐 방식이 순환 탐색 방법보다 훨씬 시간이 작게 소요되는 것을 확인했다.

<br>

### 풀이 요약

- 풀이 방법 : 다익스트라(순환 탐색 / 우선순위 큐)
- `순환 탐색` - 메모리 : 117404KB, 시간 : 1964ms
- `우선 순위 큐` - 메모리 : 122844KB, 시간 : 816ms

<br>

### 풀이 방법

**① 순환 탐색** 

1. 노드의 개수 V와 간선의 개수 E 그리고 시작점 start를 입력받는다.
2. Node 클래스 및 인접 리스트를 생성하고, E 만큼 간선의 정보를 입력받는다. 
3. INF로 초기화한 dist 배열과 방문 체크하는 visited 배열을 생성한다.
4. dist[start] = 0으로 초기화한다. 
5. 다익스트라 알고리즘을 진행한다.
    1. 방문하지 않은 노드 중에 최소 거리 비용을 가지는 노드를 선택한다.
    2. 선택한 노드를 방문 처리한다.
    3. 선택한 노드의 인접한 노드를 방문하며 최소 거리를 갱신한다. 
6. 다익스트라 알고리즘을 통해 갱신된 거리를 출력한다. 

<br>

**② 우선 순위 큐**

1. 노드의 개수 V와 간선의 개수 E 그리고 시작점 start를 입력받는다.
2. Node 클래스 및 인접 리스트를 생성하고, E 만큼 간선의 정보를 입력받는다. 
3. INF로 초기화한 dist 배열을 생성한다. 
4. dist[start] = 0으로 초기화한다.
5. 우선 순위 큐를 생성한다. cost가 작은 순서대로 정렬되도록 한다. 
6. 우선 순위 큐에 new Node(start, 0)을 생성하여 offer한다. 
7. 다익스트라 알고리즘을 진행한다.
    1. queue가 isEmpty()가 될 때 까지 반복한다.
    2. queue에 들어있는 가장 첫 번째 Node를 꺼낸다. (curNode)
    3. curNode의 비용이 현재 dist[curNode.idx] 보다 크다면 continue한다. (이 조건문이 없다면 이미 방문한 정점을 중복하여 방문할 수 있다.)
    4. curNode와 인접한 노드를 방문한다. (nextNode)
        1. 만약 dist[nextNode.idx] > dist[curNode.idx] + nextNode.cost 라면 dist 값을 갱신한다.
        2. dist 값이 갱신되었다면 큐에 new Node(nextNode.idx, dist[nextNode.idx])를 생성하여 넣어준다. 
8. 다익스트라 알고리즘을 통해 갱신된 거리를 출력한다.

<br>
