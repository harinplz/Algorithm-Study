# BOJ 골드4 14002 가장 긴 증가하는 부분 수열 4

<br>

### 풀이 요약

- 풀이 시간 : 블참 (T.T)~~
- 풀이 방법 : DP
- 메모리 : 12392KB, 시간 : 100ms

<br>

### 문제 이해

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구해야한다. 예를 들어, 수열 A가 {10, 20, 10, 30, 20, 50} 일 때 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다. 

<br>

### 풀이 방법

문제는 DP를 통해서 풀 수 있다. 또한, N의 길이가 최대 1000으로 제한되어 있기 때문에 O(N^2)의 시간 복잡도로도 충분히 시간 내에 풀 수 있다. 

<br>

먼저 **DP[i] = k 라고 하면 i 번째 수열까지 최대 증가 부분 수열의 길이가 k라고 생각**하고 문제를 풀어보자. 문제 예시를 예로 들면 

```java
dp[1] = 1 {10}
dp[2] = 2 {10, 20}
dp[3] = 1 {10}
dp[4] = 3 {10, 20, 30}
dp[5] = 2 {10, 20}
dp[6] = 4 {10, 20, 30, 50}
```

위와 같이 구할 수 있다.

<br>

i 번째 인덱스에서 그 전까지의 인덱스인 모든 j에 대해 수를 비교해준다. 그리고 만약 **arr[i] > arr[j]** 일 경우, dp[i]의 값 즉, i 번째 수열까지 최대 증가 부분 수열의 길이를 **dp[i]와 dp[j] + 1 값 중 최대값**으로 갱신한다. 이 과정을 반복하다보면 최대 증가 부분 수열의 길이를 구할 수 있다.

```java
int maxLen = 1;
dp[1] = 1;
for (int i = 2; i <= N; i++) {
    dp[i] = 1;
    for (int j = 1; j <= i; j++) {
        if (arr[i] > arr[j]) {
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
    maxLen = Math.max(maxLen, dp[i]);
}
```

<br>

가장 긴 증가하는 부분 수열을 구하려면 어떻게 해야할까? 바로 `Stack`으로 역추적을 하면 된다. i를 N부터 1까지 값을 감소시키며 **maxLen(가장 긴 증가하는 부분 수열의 길이)와 dp[i]의 값이 같다면** 스택에 넣어준다. 동시에 **maxLen 값도 감소**시킨다. 이후, 다 탐색했다면 Stack이 빌 때까지 pop()을 하며 값을 꺼내준다. 이 때 꺼내는 값을 순서대로 나열하면 바로 가장 긴 증가하는 부분 수열이다. 

```java
Stack < Integer > stack = new Stack < > ();

for (int i = N; i >= 1; i--) {
    if (maxLen == dp[i]) {
        stack.push(arr[i]);
        maxLen--;
    }
}

while (!stack.isEmpty()) {
    sb.append(stack.pop() + " ");
}
```

<br>

### 참고
https://dragon-h.tistory.com/34
