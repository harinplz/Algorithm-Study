# BOJ 골드4 1405 미친 로봇

<br>

### 풀이 요약

- 풀이 시간 : 약 1시간 (블참)
- 풀이 방법 : DFS + 백트래킹
- 메모리 : 12532KB, 시간 : 144ms

<br>

### 풀이 방법

로봇이 N번의 행동을 취한다.
이 때, 로봇이 같은 곳을 한 번보다 많이 이동하지 않을 때, 로봇의 이동 경로가 단순하다고 한다.
로봇의 이동 경로가 단순할 확률을 구하는 문제이다.

<br>

처음에는 로봇이 동 서 남 북으로 이동하는 모든 경우를 구하고, 이 경우에 따른 처리를 해줘야한다고 생각했기 때문에 중복 순열로 문제를 풀었다. 근데 N이 최대 14니까 예제를 넣어보니 시간이 꽤 오래 걸렸다. 😢 (당연함!)

그래서 `DFS + 백트래킹`으로 문제를 풀었다. (블참했음)

<br>

1. N과 동 서 남 북으로 이동할 확률을 입력받는다.
2. visited 배열을 선언한다.
    1. N이 최대 14이니까 r과 c는 15, 15에서 시작한다면 30을 벗어나지 않을 것이다.
    2. 그래서 visited 배열의 크기를 boolean[30][30]으로 초기화한후, visited[15][15]를 방문 처리해준다. 
3. DFS를 통해 이동하는 경우의 수를 찾는다.
    1. 현재 위치에서 동 서 남 북 탐방하며 1씩 이동한다.
    2. 방문한 경우에는 이동하지 않는다. (여기서 그냥 단순한 경로로 가게끔 만드는 것이다)
    3. 방문하지 않은 경우에는 visited[nr][nc] = true로 방문 처리를 해주고, cnt+1 값과 해당 방향으로 이동하는 확률을 곱해준 다음 nr, nc로 이동해준다. 
        1. 백트래킹으로 return 되었을 때, visited[nr][nc] = false 처리도 해주어서 (nr, nc)를 방문하지 않은 경우도 구해줘야한다. 
    4. cnt가 N이면 이동을 모두 완료했다는 것이기 때문에 ans에 지금까지 갱신한 비율을 더해주고 return한다.  
4. 답은 이동한 경우의 모든 확률을 더해준 값이므로, 이를 출력한다.

<br>

### 회고

- 순열은 정말 시간이 오래 걸리기 때문에 N이 작은 경우에만 시도하기.
- 위치라고 무조건 Pos class를 생성하지 말고 방문 처리할 수 있는 방법을 고민해보기.

<br>

### 참고

https://steady-coding.tistory.com/80
