# BOJ 골드5 19598 최소 회의실 개수

<br>

## 첫 번째 풀이 방법

### 풀이 요약

- 풀이 시간 : 측정 X m
- 풀이 방법 : 그리디
- 메모리 : 49984KB, 시간 : 4720ms

<br>

### 풀이 방법

<br>

회의 시간이 주어졌을 때, 모든 회의를 진행할 수 있도록 회의실의 최소 개수를 구하는 문제이다.

1. N 입력
2. start, end 를 변수로 가진 Time 클래스 생성
3. 미팅을 저장하는 리스트 생성 후 입력
    1. 시작 시간을 오름차순으로 정렬하고, 만약 같다면 끝나는 시간을 오름차순으로 정렬한다.
4. 진행 중인 회의 끝나는 시간을 저장하는 리스트 생성. 회의실의 개수를 저장하는 cnt 변수 생성 
5. 미팅 시간을 하나씩 꺼내보며 회의실을 추가해야하는 지 결정한다.
    1. 진행 중인 회의의 끝나는 시간을 확인한 후, 만약 현재 회의의 시작하는 시간보다 작거나 같다면 해당 회의가 진행 중인 회의실에서 회의가 가능한 것이므로 리스트에 들어있는 것을 빼고 현재의 회의 끝나는 시간을 넣는다.
    2. 만약, 모든 회의실에서 불가능하다면 새로운 회의실을 추가해준다.
6. 위 과정을 끝낸 후, 최종적인 cnt를 출력한다. 

<br>

문제가 제한이 2초인데 4720ms가 성공으로 떠서 다른 풀이 방법을 찾아봐야겠다 … ㅎㅎ

<hr>

<br>

## 두 번째 풀이 방법

### 풀이 요약

- 풀이 방법 : 우선 순위 큐 + 그리디
- 메모리 : 50868KB, 시간 : 604ms (1/4 🔻)

<br>

### 풀이 방법

이전 방법에는 리스트에 들어간 모든 끝나는 시간을 확인해서 만약 현재 회의의 시간보다 작거나 같다면 그 회의 끝나는 시간을 리스트에서 빼주었다.

<br>

- 두 번째 풀이 방식은 우선 순위 큐에 끝나는 시간을 넣어주는 데, pq에 제일 위에 있는 값(`pq.peek()`)과 회의의 시작 시간(`meetings.get(i).start`)을 비교한다.
- 만약, 회의의 시작 시간이 pq 제일 위에 있는 시간보다 크거나 같다면 pq의 제일 위에 있는 값(끝나는 시간 중 제일 작은 값) 을 poll 해준다. (끝난 회의실에 들어가면 되니까!) 
- 만약, 그렇지 않다면 그냥 넘어간다. (회의가 안 끝난 곳에 못 들어감!)
- 계속해서 pq에 회의 끝나는 시간을 넣어준다. (회의는 일단 해야하니까!) 
- 그리고 반복문이 끝났다면 pq의 사이즈가 회의실의 개수가 된다. 

```java
// 진행 중인 회의
PriorityQueue < Integer > pq = new PriorityQueue < > ();
pq.offer(meetings.get(0).end);

for (int i = 1; i < N; i++) {
    System.out.println(pq);
    if (pq.peek() <= meetings.get(i).start) {
        pq.poll();
    }
    pq.offer(meetings.get(i).end);
}
```

<br>

### 참고

- https://passionfruit200.tistory.com/m/457
