# BOJ 골드4 17396 백도어

### 풀이 요약

- 풀이 시간 : 약 30분
- 풀이 방법 : 다익스트라
- 메모리 : 148364KB, 시간 : 1824ms

<br>

### 풀이 방법

- 시작점 0부터 상대편 넥서스 N-1까지 갈 수 있는 최소 시간을 구하는 문제이다.
- 주의할 점은 양방향 그래프이며, N-1번 분기점(최종점)을 제외한 나머지 분기점이 적 시야에서 보이는 경우 해당 분기점으로 갈 수 없다는 것.

<br>

1. N, M 입력 (N:노드의 개수, M:간선의 개수)
2. 각 분기점이 적 시야에서 보이는 곳 인지 입력 
3. M개만큼 길 정보 입력받음. (목적지가 시야에서 보이면 갈 수 없고, 양방향 그래프이다.)
4. dist 배열을 생성한다. 0을 제외한 나머지는 INF 값으로 초기화한다.
5. 다익스트라 알고리즘을 진행한다.
    1. 우선 순위 큐를 생성한다.
    2. 큐에 Node(0(start), 0(dist))을 추가해준다.
    3. 큐가 빈 상태가 될 때 까지 최단 경로를 찾는 다익스트라 알고리즘을 반복한다.
        1. 큐에서 노드를 꺼낸다.
        2. 만약 노드의 비용이 현재 거리보다 크다면? 인접 노드를 방문하지 않고 그냥 종료한다.
        `if(curNode.cost > dist[curNode.idx]) continue;`
        3. 현재 노드와 인접한 노드를 하나 씩 방문한다.
        4. 만약 시작점으로부터 인접한 노드까지의 거리보다 시작점으로 부터 현재 노드 까지의 거리 + 현재 노드로부터 다음 인접한 노드까지의 비용이 더 작다면 값을 새로 갱신한다. 
            
            `if(dist[nextNode.idx] > dist[curNode.idx] + nextNode.cost)`
            
        5. 거리를 갱신했다면 큐에 노드를 넣어준다. (Node(nextNode.idx, dist[nextNode.idx))
6. 만약 dist[N-1] 값이 INF라면 -1을 아니라면 dist[N-1] 값을 출력한다.

<br>

### 첫 번째 시도 (67% 틀렸습니다.)

- 다익스트라 알고리즘 코드도 문제가 없어보였는데 틀려서 흠,,🤔 했는데 문제 조건을 확인하니까 
1 ≤ *t(a, b에서 갈 때 걸리는 시간)* ≤ 100,000 이고, 1 ≤ *N* ≤ 100,000 라는 조건이 주어졌었다.
- 만약, 모든 분기를 잇는 길이 있고, 그 길의 시간이 전부 100,000이라면 dist[N-1] 값은 최대 10,000,000,000 으로 int 형 범위를 넘어간다. (int는 약 20억까지)
- 그래서 cost와 dist의 변수형을 long으로 변환하니까 맞았습니다. 가 떴다.
- 문제 조건을 정말 잘 확인해야겠다 … (　-̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥᷄ _ -̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥̥᷅ )
