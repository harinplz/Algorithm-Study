# BOJ 골드5 2668 숫자고르기

### 풀이 요약

- 풀이 시간 : 측정X (블참)
- 풀이 방법 : DFS
- 메모리 : 11552KB, 시간 : 76ms

<br>

### 풀이 방법

세로 두 줄, 가로로 N개의 칸으로 이루어진 표가 있다. 첫째 줄에는 1, 2, …, N이 차례대로 있고 둘째 줄의 각 칸에는 1이상 N이하인 정수가 들어있다.

첫째 줄에서 숫자를 적절히 뽑으면, 그 뽑힌 정수들이 이루는 집합과 뽑힌 정수들의 바로 밑에 있는 정수들의 집합이 일치하는데, 이때 이러한 조건을 만족하는 정수를 가장 많이 뽑는 방법을 찾는 문제이다. 

<br>

처음에는 조합을 통해 문제를 풀려고 했는데 1 ≤ N ≤ 100 이라서 시간초과가 났다 .. (메모리 초과도 남)
방법을 고민하다가 블참을 했고 ,, 사이클을 이루는 숫자를 모으면 방법이 된다. 

<br>

사이클을 이루는 숫자를 찾기 위해 DFS로 확인하고, 시작한 값과 같은 값이 있다면? 리스트에 추가한다. 

1. N을 입력한 후, arr과 visited 배열을 선언한다. 
2. 1부터 N까지 반복하며 사이클을 이루는 숫자를 찾는다.
    1. 처음 시작하는 숫자를 초기화한다. (start 변수)
    2. 방문 체크를 한 후, DFS 탐색을 시작한다.
        1. 방문하지 않은 곳을 탐색하며 start 값과 arr[idx] 값을 비교하며 같은 지를 찾는다.
        2. 만약 같다면 리스트에 추가한다. 
        3. 방문 체크를 해제하는 이유는 다음 반복에서도 얘를 방문했는 지 재확인해야하기 때문이다. 
3. 탐색이 끝났으면, 리스트를 정렬하고 리스트의 사이즈와 요소들을 오름차순으로 출력한다.
