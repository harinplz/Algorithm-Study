# BOJ 골드4 2110 공유기 설치

### 풀이 요약

- 풀이 시간 : 측정 X (블참)
- 풀이 방법 : 이분 탐색
- 메모리 : 28364KB, 시간 : 272ms

<br>

### 풀이 방법

처음에는 먼저 N의 위치를 입력받고, 이를 오름차순으로 정렬했다. 그 다음 인접한 두 공유기 사이의 거리를 가능한 크게 하려면 처음 위치랑 마지막 위치에 공유기를 설치하자. 라고 생각한 다음 현재 제일 인접한 거리가 최대인 집을 찾으면서 설치를 해주었다. 당연히 근데 이런식으로 풀면 인접한 두 공유기 사이의 거리가 최대가 되지 않는 경우도 생기기 때문에 풀리지 않았다 😢 

<br>

블참한 결과, 문제는 공유기를 어디에 설치하는 것에 집중하는 것이 아니라 **‘거리’** 에 집중해야한다! 

<br>

1. N(집 수), C(공유기를 설치해야하는 수)를 입력받는다.
2. 배열을 입력받은 후 오름차순으로 정렬한다.
3. 처음에 최소 간격을 1, 최대 간격을 arr[N-1]로 정한다. 
4. 이후, 이분 탐색을 진행하며 공유기를 설치할 수 있는 거리를 찾는다.
    1. `mid = (left + right) / 2` 로 최소 거리를 설정한다. 
    2. 집을 하나씩 방문하며 이전에 공유기를 설치한 집에서 지금 집까지의 거리가 mid보다 크다면 공유기를 설치해준다. (`cnt++` : 공유기 설치 수 변수)
    3. 만약 cnt가 C보다 작을 때는 최소 거리를 더 작게해도 된다는 것이므로 right = mid - 1로 처리한다.
    4. 만약 cnt가 C보다 크거나 같을 때는 최소 거리를 크게해도 된다는 것이므로 left = mid + 1 로 처리한다.
    5. 만약 cnt가 C와 같을때는 이 최소 거리가 가장 인접한 두 공유기 사이의 거리를 최대로 하는 거리인 지 알 수 없기 때문에 최소 거리를 늘린다.
    
    ⇒ 즉, cnt가 C랑 같아져도 가장 인접한 두 공유기 사이의 거리를 최대로 하는 지 알 수 없기 때문에 최소 거리를 늘리며 최대일 때를 찾아야한다. 즉, Upper bound를 찾으면 된다.  
    
5. Upper bound는 탐색 값을 초과하는 첫 번째 값을 가리키므로, 1을 빼준 값이 답이 된다. 

<br>

코드 길이는 굉장히 짧은데 생각해내기가 너무 어렵다 😢 이분 탐색 문제는 계속해서 풀어봐야할 것 같다 😢 

<br>

### 참고

- https://st-lab.tistory.com/277
- [https://velog.io/@db_jam/알고리즘백준-2110번-공유기-설치-JAVA](https://velog.io/@db_jam/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%B0%B1%EC%A4%80-2110%EB%B2%88-%EA%B3%B5%EC%9C%A0%EA%B8%B0-%EC%84%A4%EC%B9%98-JAVA)
