# BOJ 실버1 9081 단어 맞추기

<br>

### 풀이 요약

- 풀이 시간 : 오후 8시 40분 ~ 9시 34분
- 풀이 방법 : 구현 / 문자열
- 메모리 : 11432KB, 시간 : 80ms

<br>

### 풀이 방법

처음에는 단어가 주어졌을 때 그 단어의 문자들을 조합해서 하나씩 찾아보려고 했는데 시간이 너무 오래 걸릴 것 같았다. 또한 문제에서 사전 순으로 정렬했을 때 주어진 단어의 다음에 올 단어만 찾으면 된다고 했으므로 전부 다 찾을 필요는 없어보였다! 그래서 어떻게 하면 다음에 올 문자를 찾을 수 있을 지 고민함 … 🤔 

일단, 문제의 예시인 HELLO를 예로 생각해보겠다. 

HELLO 에 주어진 문자인 ‘H’ ‘E’ ‘L’ ‘L’ ‘O’를 가지고 단어를 만들 고 사전 순으로 정렬할 때 다음에 올 단어는 HELOL이다. 왜 그럴까? 다른 방법도 있겠지만 사전 순 정렬을 직관적으로 알기 위해 나는 각 문자를 아스키코드로 변환해보았다. 그럼 각각 H(72) E(69) L(76) L(76) O(79)이다. 여기서 이 단어의 다음에 올 단어는? 당연히 각각의 문자를 비교했을 때 **앞 인덱스에서 더 큰 아스키코드 값**을 가진 단어이다. 그러면 뒤에서부터 0까지 인덱스를 줄여가며 두 개의 문자를 비교했을 때 **앞 문자보다 뒷 문자의 아스키코드 값이 큰 경우** 두 문자의 위치를 바꿔주면 되지 않을까? 라고 생각해볼 수 있다!

그러면 먼저 H(72) E(69) L(76) **L(76)** O(79)가 있을 때, HELLO의 length 보다 2작은 인덱스 부터 살펴보겠다. (왜냐하면 제일 마지막 문자는 뒤에 비교할 문자가 없으니까) 이 인덱스를 i라고 했을 때, i 뒤에 i 자리에 있는 문자보다 큰 아스키코드 값이 있다면? i 자리에 더 큰 아스키코드 값을 가지는 문자가 들어갈 수 있게 되는 것이다. HELLO와 같은 경우에는 **O가 L보다 아스키코드 값이 크기 때문에** O자리에 L이 들어가게 되고 L자리에 O가 들어가게 된다. 

하지만 DRINK와 같은 경우에는 어떨까? D(68) R(82) **I(73)** N(78) K(75)에서 앞 인덱스보다 뒷 인덱스에서 더 큰 아스키 코드 값을 가지는 경우는 **인덱스 2, I일때**이다. 하지만, 여기서 I랑 N의 자리를 바꾸면 될까? 아니다. I의 자리, 인덱스 2에는 지금까지의 아스키코드 값 중 **가장 작지만 I의 아스키 코드 보다 큰 값**이 들어가야한다. N과 K중에 아스키 코드 값이 작은 것은 **K**이므로 I자리에 K가 들어가게 되고 남은 I와 N을 오름차순으로 정렬하여 D R K I N 이라는 결과값이 나오게 된다. 

위와 같은 생각을 바탕으로 아래 코드를 작성했다. List를 굳이 쓰지 않아도 구현될 것 같아서 안 쓰는 방법도 고민해봐야겠다. 어려운 문제는 아니었지만 블참을 안하고 스스로 생각해냈다는 것에 칭찬을 하고 싶어요 👍🏻 

```java
for (int i = str.length() - 2; i >= 0; i--) {
    for (int j = i + 1; j < str.length(); j++) {
        if (charNum[i] < charNum[j]) { // charNum은 단어의 각 문자마다 아스키 코드 값을 저장한 배열이다. 
            int minIdx = j;
            for (int m = j + 1; m < str.length(); m++) {
                if (charNum[i] < charNum[m] && charNum[m] < charNum[minIdx]) minIdx = m;
            }
            List < Character > list = new ArrayList < > ();
            // 남은 애들 넣기 
            for (int k = i + 1; k < str.length(); k++) {
                if (k == minIdx) list.add((char) charNum[i]);
                else list.add((char) charNum[k]);
            }
        }
    }
}
```
