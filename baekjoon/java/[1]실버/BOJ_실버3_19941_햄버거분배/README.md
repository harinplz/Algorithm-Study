# BOJ 실버3 19941 햄버거 분배

### 풀이 요약

- 풀이 시간 : 측정 X
- 풀이 방법 : 그리디
- 메모리 : 11924KB, 시간 : 88ms

<br>

### 풀이 방법

식탁의 길이 N, 햄버거를 선택할 수 있는 거리 K, 사람과 햄버거의 위치가 주어졌을 때 햄버거를 먹을 수 있는 사람의 최대 수를 구하는 문제이다.

<br>

**처음 풀이 방법**

1. 사람 ‘P’를 발견하면 해당 위치가 idx라고 했을 때, idx-k 부터 idx+k까지 햄버거 ‘H’를 찾는다.
2. 햄버거를 찾았다면 idx의 우선 순위 큐에 햄버거 인덱스를 저장해준다.
3. 모든 햄버거를 찾았다면, 다시 0부터 N까지 반복하면서 우선 순위 큐의 크기가 0보다 큰 곳을 찾는다.
4. 우선 순위 큐에 들어있는 숫자 중 방문하지 않은 수의 햄버거를 먹는다. 먹을 때 마다 ans를 증가시켜준다. 
5. ans를 출력한다.

<br>

위 방식으로 문제를 풀었는데, 우선 순위 큐를 계속 생성해서 사용하다 보니까 메모리는 물론 시간 또한 많이 나왔다. `(메모리: 23440KB, 시간 : 300ms)` 그리고 내가 푼 방법을 다시 보니까 그냥 먹을 수 있는 햄버거 중에 **가장 왼쪽 인덱스의 햄버거**를 먹으면 되는구나! 라고 깨달았다. 

<br>

**최종 풀이 방법**

1. 사람 ‘P’를 발견하면 해당 위치가 idx라고 했을 때, idx-k 부터 idx+k까지 햄버거 ‘H’를 찾는다.
2. 햄버거는 가장 왼쪽에 있는 햄버거를 먹어야한다. 
    1. 현재 위치 이전에 있는 햄버거는 k를 K부터 1까지 감소시키며 먹을 수 있는 햄버거를 찾는다. (왼쪽부터 먹기 위함.)
    2. 만약 찾았다면 `isEat`(햄버거를 먹었는 지 확인하는 변수)를 true로 처리해주고 `hamburger[i-k] = ‘E’`로 해준다. ans 값도 증가해준다.
    3. 현재 위치 이후에 있는 햄버거를 먹기 전에 `isEat`가 true이면 continue 한다.
    4. 현재 위치 이후에 있는 햄버거는 k를 1부터 K까지 증가하며 먹을 수 있는 햄버거를 찾는다. (왼쪽부터 먹기 위함.)
    5. 만약 찾았다면 `hamburger[i-k] = ‘E’`로 해주고 ans 값도 증가해준다.
3. 모든 과정이 끝났다면 ans를 출력해준다.
