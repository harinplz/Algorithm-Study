# BOJ 실버3 14501 퇴사

<br>

### 풀이 요약

- 풀이 시간 : 오후 3시 5분 ~ 3시 39분
- 풀이 방법 : DP
- 메모리 : 11564KB, 시간 : 72ms

<br>

### 풀이 방법

얼마전에 공부했던 LIS를 사용해서 문제를 풀었다. LIS란 최장 증가 부분 수열인데, 배열 중 일부 원소를 골라 만든 수열 중 각 원소가 이전 원소보다 큰 조건을 만족할 때 그 중에서 제일 긴 수열을 고르는 것이다. 사실 이게 LIS 인지는 모르겠으나 이전 값과 비교하여 더 큰 값으로 갱신하는 것이 유사해서 LIS 방법을 차용했다. (ㅎㅎ) 

dp 배열은 1차원 배열로 만들고, dp[n]이면 n일차 일때 백준이가 벌 수 있는 최대 금액을 저장했다. 문제에서는 상담 일자와 상담 가격이 주어졌고, 이를 활용해서 코드에 조건을 주면 된다. 만약 7일 후에 퇴사하는데 6일차에 4일 상담을 잡을 수는 없다. 이 때문에 `if(time[i] + i > N+1) continue;` 란 코드를 작성하여 상담의 마지막 날이 퇴사 이후가 될 경우 상담을 잡지 못하게 제한했다. 

또한, LIS 방법에서는 이전 값보다 큰 값일 때 LIS, 최장 증가 부분 수열을 갱신했다면 이 문제에서는 i일차 이전 날 + 이전 날의 상담 기간이 i일차를 넘지 못할 때 최대 가격을 갱신할 수 있다. 즉, `if (j + time[j] <= i)` 일 때만 가능하다. 이 모든 것을 코드로 표현하면 다음과 같다.

```java
int dp[] = new int[N + 1];
dp[1] = cost[1];
int ans = time[1] + 1 > N + 1 ? 0 : dp[1]; // 한 번도 상담을 안할 수 있다는 것을 생각! 

for (int i = 2; i <= N; i++) {
    if (time[i] + i > N + 1) continue;
    dp[i] = cost[i];
    for (int j = 1; j < i; j++) {
        if (j + time[j] <= i) {
            dp[i] = Math.max(dp[i], dp[j] + cost[i]);
        }
    }

    ans = Math.max(ans, dp[i]);
}
```

<br>

주의할 점은 처음 답을 초기화할때, 한 번도 상담을 못할 수 있다는 것을 생각해야한다. 1일차의 상담 기간이 너무 길어 퇴사일을 넘어서면 처음 답이 dp[1]이 될 수 없기 때문에 `int ans = time[1] + 1 > N + 1 ? 0 : dp[1];` 로 제한을 두어야한다.
