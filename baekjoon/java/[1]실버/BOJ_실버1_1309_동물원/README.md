# BOJ 실버1 1309 동물원 

<br>

## 풀이 방법 
- 사자가 동물원 우리에 들어가는 경우의 수를 나눠서 생각했다.
- 사자를 넣거나 안 넣을 수 있고, 또한 N-1 줄이 비었는지 안 비었는지 생각해야한다.

<br>


<img width="700" alt="스크린샷 2023-12-18 오후 6 08 37" src="https://github.com/harinplz/Algorithm-Study/assets/62701446/10c863e6-f4fb-4fe5-affb-2dd9bea1c440">

- 위 그림처럼, 만약 전 줄이 비었을 때는 이전 경우에서 * 3 만큼 늘어나고, 전 줄이 비지 않았을 때에는 이전 경우에서 * 2 만큼 늘어났다.
- 또한, N-1 줄이 비어있는 경우는 D[i-2] 의 값과 같았다. 
- 이를 통해 다음과 같은 점화식을 만들 수 있었다. `dp[i] = dp[i-2] * 3 + (dp[i-1] - dp[i-2]) * 2`

<br>

## 다른 풀이 방법
- 문제를 풀고보니, 다른 방법을 더 많이 사용하신 것 같아서 참고.
- 2차원 배열을 통해서 총 3가지의 경우를 나타낼 수 있다.
- **dp[n][0]** : 두 개의 방 중에 사자를 아예 넣지 않은 경우
- **dp[n][1]** : 두 개의 방 중에 사자를 왼쪽 방에 넣은 경우
- **dp[n][2]** : 두 개의 방 중에 사자를 오른쪽 방에 넣은 경우

<br>

- 이번 방에 사자를 넣지 않을 경우는, 이전 방에서 사자가 어떤 방에 들어있든지 상관이 없다.
- 왼쪽 방에 넣을 경우는, 이전 방에 오른쪽에 있는 경우 혹은 아무 방에도 없는 경우이다.
- 오른쪽 방에 넣을 경우는, 이전 방에 왼쪽에 있는 경우 혹은 아무 방에도 없는 경우이다.
- 위 과정을 통해 밑과 같은 점화식을 세울 수 있다.
``` java
dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2];
dp[i][1] = dp[i-1][0] + dp[i-1][2];
dp[i][2] = dp[i-1][0] + dp[i-1][1];
```

<br>

### 회고
- 블참을 안 하고 내 힘으로 풀어서 뿌듯하다.
- 그런데 확실히 블참으로 푼 코드가 논리적으로 와닿아서 이렇게 생각할 수 있도록 노력해야겠음!

<br>

### 참고
- [[백준 - 1309번] 동물원 - 자바(JAVA) 정리 및 해설](https://sundries-in-myidea.tistory.com/78)
