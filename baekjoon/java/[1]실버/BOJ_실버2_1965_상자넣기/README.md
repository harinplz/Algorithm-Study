# BOJ 실버2 1965 상자넣기

<br>

### 풀이 요약

- 풀이 시간 : 오전 9시 45분 ~ 오전 10시 30분
- 풀이 방법 : DP / LIS(최장 증가 부분 수열)
- 메모리 : 11924KB, 시간 : 108ms

<br>

### 풀이 방법

문제는 **LIS**를 사용하면 쉽게 풀리는 문제이다. LIS는 **최장 증가 부분 수열**로 원소가 n개인 배열의 일부 원소를 골라내서 만든 부분 수열 중, **각 원소가 이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열**을 말한다.

문제에서 예를 들어 보았을 때 {1, 5, 2, 3, 7} 과 같은 수열이 있을 경우 LIS는 {1, 2, 3, 7} 이 된다. 그러면 최장 증가 부분 수열을 어떻게 구하면 될까? 바로 `DP`를 사용하면 된다.

```java
for (int i = 1; i <= N; i++) {
     dp[i] = 1;
     for (int j = 1; j < i; j++) {
         if (box[j] < box[i]) {
             dp[i] = Math.max(dp[i], dp[j] + 1);
         }
         ans = Math.max(dp[i], ans);
     }
 }
```

<br>

먼저 주어진 배열에서 인덱스를 한 칸씩 늘려가며 확인한다. 그리고 i보다 작은 인덱스를 하나 씩 살펴보며 `box[j] < box[i]` 인 값이 있을 경우, dp[i]를 업데이트 해준다. 

(1) j번째 인덱스에서 끝나는 최장증가 부분 수열 마지막에 arr[i]를 추가했을 때 LIS 길이와 (2) arr[i]를 추가하지 않은 기존의 dp[i] 값 중 더 큰 값으로 **dp[i]의 값을 업데이트**한다. 

하지만, 위 알고리즘은 이중 반복문이기 때문에 **시간 복잡도가 O(N^2)**이다. 이 문제에서는 N의 개수가 1000이하였기 때문에 시간 내에 풀 수 있었지만 만약 더 큰 값이라면? 시간 초과가 날 가능성이 크다. 이럴 때 시간 복잡도를 개선하기 위해 **이분 탐색을 활용한 LIS**를 구하면 된다. (다음 시간에 … )

<br>

### 참고

https://chanhuiseok.github.io/posts/algo-49/
