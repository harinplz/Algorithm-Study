# BOJ 실버1 2531 회전 초밥

### 풀이 요약

- 풀이 시간 : 약 25분
- 풀이 방법 : 브루트포스 / 슬라이딩윈도우
- 메모리 : 295548KB, 시간 : 2972ms / 16464KB, 시간 : 144ms

<br>

### 풀이 방법

회전 초밥집에서 초밥을 많이 팔기 위해 행사를 한다. 

1. 벨트의 임의의 한 위치부터 k개의 접시를 연속해서 먹을 경우 할인된 정액 가격으로 제공한다.
2. 각 고객에게 초밥의 종류가 하나 쓰인 쿠폰을 발행하고, 1번 행사에 참가할 경우 이 쿠폰에 적혀진 종류의 초밥 하나를 추가로 제공한다. 

이때, **손님이 먹을 수 있는 초밥 가짓수의 최댓값**을 구하는 문제이다.

<br>

처음에는 브루트포스로 모든 경우에 대해서 생각했는데 메모리랑 시간이 너무 크게 나와서 슬라이딩 윈도우 방식으로 바꿔서 풀었다.

<br>

### 브루트포스

<br>

1. 벨트위에 있는 초밥을 입력받는다.
2. 최대 초밥 가짓수를 구한다.
    1. i를 0부터 N-1까지 반복한다. 이때, Set을 생성해서 중복을 체크한다.
    2. k개의 접시를 연속해서 먹기 위해 i부터 i+k-1까지 초밥을 생성한 Set에 넣어준다.
    3. 만약 생성한 Set의 크기와 k가 같은 경우와 다른 경우를 나눠서 최댓값을 갱신한다.
    4. 또한, 현재 연속해서 먹은 초밥에 쿠폰으로 제공되는 초밥이 포함되었는 지 확인한다.
3. 반복이 끝난 후, 최대 초밥 가짓수를 출력한다.

<br>

### 슬라이딩 윈도우

<br>

- 슬라이딩 윈도우는 일정한 크기의 윈도우를 옮겨가며 앞에 있던 건 빼고 뒤에 있는 건 넣어주는 방식이다.
- 초밥은 임의의 k개의 접시를 연속해서 먹는 경우이기 때문에 다음 인덱스로 넘어갈 때, 앞에 있는 초밥은 빼주고 뒤에 있는 초밥을 넣어주면 된다.

<br>

1. 현재 벨트위에 있는 초밥을 입력받는다.
2. d(초밥 가짓수) 크기의 초밥 배열을 생성한다. 
3. 인덱스 0부터 k-1까지 초밥을 확인한다. 만약 벨트위에 초밥이 있다면 sushi[belt[i]] 값을 1 증가시킨다.
4. 1부터 d까지 sushi[i] 값이 0보다 클 경우 cnt(가짓 수) 값을 증가시킨다. max 값은 cnt로 초기화한다.
5. 슬라이딩 윈도우로 N-1까지 인덱스로 시작하는 초밥까지 반복을 진행한다. 
    1. max 값이 cnt 보다 작거나 같을 때 쿠폰이 있는 지 여부를 확인하고 max 값을 갱신한다.
    2. 슬라이딩 윈도우는 현재 기준 인덱스 i에서 i 인덱스의 초밥은 빼고, (i+k) % N 의 초밥은 넣어줘야한다. 
    3. 초밥을 뺄 때, sushi[belt[i]] 값을 1 감소시키고, 만약 현재 벨트위에 초밥이 없다면, 즉 sushi[belt[i]] == 0 이라면 cnt 값을 감소시킨다.
    4. 다음 초밥을 더할 때, sushi[belt[(i+k)%N]] 값을 1 증가시키고, 만약 sushi[eatSushi] 값이 1이라면 방금 새로운 초밥을 먹었다는 뜻이기 때문에 cnt 값을 증가해준다. 
6. 슬라이딩 윈도우 알고리즘이 끝난 후, 최대 초밥 가짓수를 출력한다.
