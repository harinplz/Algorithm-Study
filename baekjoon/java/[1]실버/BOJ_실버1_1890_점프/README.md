# BOJ 실버1 1890 점프

<br>

### 풀이 요약

- 풀이 시간 : 오후 2시 49분 ~ 오후 3시 11분
- 풀이 방법 : DP
- 메모리 : 11820KB, 시간 : 84ms

<br>

### 풀이 방법

가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프해서 간다. 

각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미하며, 반드시 오른쪽이나 아래쪽으로만 이동해야한다. 

가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 **규칙에 맞게 이동할 수 있는 경로의 개수**를 구하는 프로그램

<br>

- 처음 시작 점인 0,0 좌표에서 갈 수 있는 곳에 DP 배열 값을 + 1을 해준다. (경로의 수를 더해준 것이다.)
- 모든 좌표를 방문하며 DP 배열 값이 0이 아닐 때 경로의 수를 더해준다.
    - 오른쪽이나 아래쪽으로 각 칸에 적혀있는 수만큼 이동 가능하며, 범위에 벗어날 경우 이동하지 못한다.
    
    ```java
    if (dp[i][j] != 0 && map[i][j] != 0) {
        if (j + map[i][j] < N) dp[i][j + map[i][j]] += dp[i][j];
        if (i + map[i][j] < N) dp[i + map[i][j]][j] += dp[i][j];
    }
    ```
    
- 마지막까지 다 구하고 나서 DP 배열의 가장 오른쪽 아래 값을 출력하면 된다.

<br>

⚡ 경로의 개수는 2^63-1보다 작거나 같으니 long 타입으로 DP 배열을 선언해줘야 한다. 

- int 범위는 -2^31 ~ 2^31 - 1 이고 long 범위는 -2^63 ~ 2^63 - 1이다.
