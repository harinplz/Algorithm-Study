# BOJ 실버5 7785 회사에 있는 사람

<br>

## 요약 
- 풀이 시간 : 12분
- 풀이 방법 : Set 사용

<br>

## 풀이 방법
- 자료구조 TreeSet을 사용
- enter가 입력되면 name을 set에 add해주고, leave가 입력되면 name을 set에서 remove해준다.
- 역순으로 출력해야했으므로, TreeSet 선언 시 Collections.reverseOrder()을 넣어준다.  
  `Set<String> set = new TreeSet<>(Collections.reverseOrder());`

<br>

## 주의할 점
- 처음에는 `list` 로 문제를 풀었더니 **시간 초과**가 발생했다.
- 이유는 list와 set의 검색 속도 차이 때문에 발생

<br>

## list와 set의 검색 속도 차이
- 먼저, List는 순서가 있는 데이터의 집합이고, Set은 순서가 없고 중복을 허용하지 않는 데이터의 집합이다.

<br>

### List
- **List**는 순서가 있기 때문에 인덱스를 사용하여 원하는 위치 요소에 직접 접근할 수 있다. 그래서 찾고자하는 요소의 인덱스를 알고 있다면 검색 속도는 `O(1)`이 될 수 있다.
- 하지만, 요소의 인덱스를 모를 경우, 선형적으로 검색하기 때문에 일반적으로 `O(N)`의 시간이 소요된다.

<br>

### Set
- **Set**은 순서가 없고 중복을 허용하지 않기 때문에 인덱스를 사용하여 요소에 직접 접근하는 것은 불가능하다.
- 검색 속도는 Set의 구현에 따라 다를 수 있는데, **HashSet**은 일반적으로 `O(1)`의 검색 시간을 가지며, **TreeSet**은 일반적으로 `O(logN)`의 검색 시간을 가진다.
- **HashSet**은 **해시 함수**를 사용하여 데이터를 저장한다, 각 요소는 해시코드를 기반으로 저장되는데 이를 통해 직접 해당 요소의 위치를 찾아갈 수 있으므로 검색 시간이 `O(1)`이다.
- 또한, **TreeSet**은 **이진 검색 트리**를 사용하여 데이터를 저장한다. 각 단계마다 현재 노드와 찾고자 하는 값의 비교를 통해 다음에 어떤 서브 트리로 이동할 지 결정하므로, 트리의 높이에 비례하는 검색 시간 `O(logN)`이 소요된다.
  
