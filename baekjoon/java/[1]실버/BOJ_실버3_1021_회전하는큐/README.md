# BOJ 실버3 1021 회전하는 큐

<br>

### 풀이 요약

- 풀이 시간 : 오후 4시 39분 ~ 오후 5시 32분
- 풀이 방법 : 자료구조 (덱)
- 메모리 : 11636KB, 시간 : 76ms

<br>

### 풀이 방법

자료구조 **덱**을 사용하여 푸는 문제이다. 
➕ `덱(Dequeue)`이란 Double Ended Queue를 줄여서 부르는 말로, **양쪽 끝에서 삽입과 삭제가 모두 가능한 자료 구조**의 한 형태이다.

<br>

1. **만든 덱에 1부터 N까지의 값을 순차적으로 넣어준다.**
2. **지민이가 뽑으려는 원소를 하나 씩 찾는다.**
- 이 때, 연산의 최솟값을 구하려면 어떻게 해야할까? 덱에서 찾고자 하는 원소의 인덱스를 구해야한다.
- 인덱스를 어떻게 구해야할까? ⭐ (난 여기서 막혔다.) ⇒ 바로 `iterator`를 사용하면 된답니다. 🚨
- iterator를 사용하여 index를 찾는다.
3. **Index의 값에 따라 1번 연산, 2번 연산, 3번 연산을 한다.** 
- index 값이 0이라면 바로 꺼내는 1번 연산
- index 값이 덱의 사이즈 - idx - 1 값 보다 작거나 같다면 2번 연산
- index 값이 덱의 사이즈 - idx -1 값보다 크다면 3번 연산을 한다.

<br>

⬆️ 위에서 index 값을 덱의 사이즈 - idx - 1과 비교하는 이유는?

연산의 최솟값을 구하기 위함이다. 예시로 1 2 3 4 5 가 덱 안에 들어있을 때를 가정해보자. 

2는 덱에서 인덱스 1이다. 인덱스 1일 때 2번 연산을 해야하는 횟수는 1번이다. 

인덱스 1일 때 3번 연산을 해야하는 횟수는 덱의 마지막 인덱스(5-1) - index(1) = 인 3번이다. 이렇게 덱의 마지막 인덱스 - 1의 값이 3번 연산을 해야하는 횟수이고, 인덱스 값이 2번 연산을 해야하는 횟수이므로 이 둘을 비교하여 더 최솟값을 가지는 쪽으로 연산을 해주면 된다!!! ✨ 

<br>

4. **위 과정을 지민이가 찾고자 하는 원소를 다 찾을 때 까지 반복한다.**

<br>

### 재풀이 (02/02) 맞았습니다!

- 블참안하고 풀이 방법을 생각해서 잘 풀었다!! 이전이랑 다른 코드로 작성했는데, 이게 내가 이해하면서 푸니까 더 직관적으로 잘 이해되는 것 같다. (ㅎㅎ)
- 풀이 순서를 생각하고 → 이를 기반으로 코드를 작성했다. 요 방법으로 푸는 연습을 반복적으로 합시닷

<br>

1. 입력
2. 원소를 연산을 사용해서 순서대로 뽑아한다. 
    1. 뽑을 수를 입력받는다.
    2. 뽑을 수의 덱에서 인덱스를 찾는다. (iterator를 사용한다.)
    3. 현재 큐에서 2번 연산이 나은지 3번 연산이 나은지 판단한다. (idx ≤ size / 2 + 1)
    4. 판단 후 연산을 선택해서 수를 하나 씩 꺼낸다 (ans++)
3. 연산의 총 합, 즉 연산의 최솟값을 출력한다.
